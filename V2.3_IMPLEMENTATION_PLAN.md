# AutoUniTestGen v2.3 実装計画書

## 🎯 バージョン目標

**v2.3: 期待値の自動推論による完全自動化**

### 目標指標
- 自動化率: 95% → **98%**
- TODOコメント: 平均50個 → **10個以下**
- 手動修正時間: 5分 → **1分以下**

---

## 📋 実装する機能

### 1. 期待値推論エンジン (ExpectationInferenceEngine)

#### 1.1 条件分岐からの推論
```c
// 条件: if (result == 0)
// 真の場合の期待値: result = 0
// 偽の場合の期待値: result != 0 (例: 1)
```

#### 1.2 戻り値からの推論
```c
// 関数定義: int func() { return error_code; }
// 期待値: 戻り値をチェック
TEST_ASSERT_EQUAL(expected_return, actual_return);
```

#### 1.3 グローバル変数への影響推論
```c
// 条件内でグローバル変数を変更
if (condition) {
    global_var = 10;
}
// 期待値: TEST_ASSERT_EQUAL(10, global_var);
```

### 2. スマートアサーション生成 (SmartAssertionGenerator)

#### 2.1 変数タイプ別アサーション選択
- 整数型: `TEST_ASSERT_EQUAL`
- ポインタ: `TEST_ASSERT_NOT_NULL` / `TEST_ASSERT_NULL`
- ブール値: `TEST_ASSERT_TRUE` / `TEST_ASSERT_FALSE`
- 配列: `TEST_ASSERT_EQUAL_ARRAY`

#### 2.2 条件に基づく値設定
- 比較演算子から境界値を推論
- switch文からcase値を推論
- ビット演算からマスク値を推論

### 3. コンテキスト解析器 (ContextAnalyzer)

#### 3.1 変数の役割判定
- 入力変数 vs 出力変数
- 一時変数 vs 永続変数
- 制御変数 vs データ変数

#### 3.2 関数の副作用検出
- グローバル変数への書き込み
- ポインタ経由の変更
- 外部関数呼び出しの影響

---

## 🛠️ 技術的実装詳細

### Phase 1: AST解析の強化

```python
class EnhancedASTAnalyzer:
    def analyze_branch_effects(self, ast_node):
        """分岐内の処理を解析"""
        - 変数への代入を検出
        - 関数呼び出しを記録
        - 戻り値を特定
        
    def extract_variable_flow(self, function_ast):
        """変数のデータフローを追跡"""
        - 定義-使用チェーン構築
        - 変数の生存期間分析
```

### Phase 2: 推論エンジン実装

```python
class ExpectationInferenceEngine:
    def infer_from_condition(self, condition, truth_value):
        """条件から期待値を推論"""
        # 例: "x > 10" かつ truth_value=True → x=11
        
    def infer_from_assignment(self, ast_node):
        """代入文から期待値を推論"""
        # 例: "result = func()" → result値をチェック
        
    def infer_from_return(self, return_node):
        """return文から期待値を推論"""
        # 例: "return ERROR_CODE" → 戻り値チェック
```

### Phase 3: アサーション生成

```python
class SmartAssertionGenerator:
    def generate_assertion(self, variable, expected_value, context):
        """適切なアサーションを生成"""
        - 変数の型を判定
        - 適切なTEST_ASSERT_*を選択
        - 期待値を設定
        
    def generate_todo_with_hint(self, variable, context):
        """より具体的なTODOを生成"""
        # 例: "// TODO: error_codeが0以外の値を確認"
```

---

## 📊 実装優先順位

### 優先度 高: 基本的な期待値推論
1. **比較演算子からの推論** ✨
   - `x > 10` → x = 11
   - `y == 0` → y = 0
   - `z != null` → z = valid_pointer

2. **代入文からの推論**
   - 直接代入の検出
   - 関数戻り値の追跡

### 優先度 中: コンテキスト認識
3. **変数の役割判定**
   - 入力/出力の自動識別
   - グローバル変数の影響追跡

4. **関数の副作用検出**
   - グローバル状態の変更
   - ポインタ経由の変更

### 優先度 低: 高度な推論
5. **複雑な条件の解析**
   - 複合条件の分解
   - ビット演算の解釈

---

## 🧪 テスト計画

### サンプルケース1: 単純な条件
```c
if (error_code == 0) {
    return SUCCESS;
}
```
期待される推論:
- True: error_code = 0, 戻り値 = SUCCESS
- False: error_code = 1, 戻り値 ≠ SUCCESS

### サンプルケース2: グローバル変数
```c
if (flag) {
    global_counter++;
}
```
期待される推論:
- True: global_counter が増加
- False: global_counter が不変

### サンプルケース3: 複雑な条件
```c
if ((status & MASK) == EXPECTED) {
    process_data();
}
```
期待される推論:
- True: status にMASKビットが設定
- False: status にMASKビットが未設定

---

## 📈 成功指標

### 定量的指標
- ✅ TODOコメント削減: 80%以上
- ✅ 正しい期待値設定: 70%以上
- ✅ ビルドエラー: 0件維持

### 定性的指標
- ✅ 生成コードの可読性向上
- ✅ デバッグ時間の短縮
- ✅ テストの信頼性向上

---

## 🗓️ 実装スケジュール

### Week 1: 基礎実装
- [ ] EnhancedASTAnalyzer
- [ ] 基本的な期待値推論

### Week 2: エンジン開発
- [ ] ExpectationInferenceEngine
- [ ] SmartAssertionGenerator

### Week 3: 統合とテスト
- [ ] 既存コードとの統合
- [ ] 包括的なテスト

### Week 4: 最適化と文書化
- [ ] パフォーマンス最適化
- [ ] ドキュメント作成

---

## 🔍 リスクと対策

### リスク1: 誤った推論
- **対策**: 保守的なアプローチ、不確実な場合はTODO

### リスク2: パフォーマンス低下
- **対策**: キャッシング、増分解析

### リスク3: 複雑性の増大
- **対策**: モジュラー設計、段階的実装

---

## 📝 実装チェックリスト

- [ ] AST解析の強化
- [ ] 条件からの期待値推論
- [ ] 代入文の追跡
- [ ] 戻り値の推論
- [ ] グローバル変数の影響解析
- [ ] スマートアサーション生成
- [ ] TODOコメントの改善
- [ ] 統合テスト
- [ ] ドキュメント更新
- [ ] リリースノート作成
